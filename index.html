<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puer Aeternus Bingo</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text x=%22-.15em%22 y=%22.9em%22 font-size=%2290%22>ðŸŽ­</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            padding-top: 80px;
        }

        h1 {
            color: white;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            position: relative;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 150px;
        }

        .controls h3 {
            margin: 0;
            font-size: 14px;
            color: #2c3e50;
            text-align: center;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .control-btn {
            background: #3498db;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #2980b9;
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .item-count {
            font-size: 16px;
            font-weight: bold;
            color: #2c3e50;
            min-width: 40px;
            text-align: center;
        }

        .shuffle-btn {
            display: inline-flex;
            align-items: center;
            justify-content: space-evenly;
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shuffle-btn > :nth-child(odd) {
            font-size: large;
        }

        .shuffle-btn:hover {
            background: #229954;
            transform: translateY(-1px);
        }

        .shuffle-btn:active {
            transform: translateY(0);
        }

        .bingo-container {
            display: grid;
            gap: 10px;
            max-width: 800px;
            min-width: 0;
            width: 100%;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            overflow: hidden;
            position: relative;
        }

        .bingo-tile {
            aspect-ratio: 1;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            user-select: none;
            position: relative;
            min-width: 0;
            min-height: 0;
            perspective: 1000px;
        }

        .tile-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform var(--flip-duration);
            transform-style: preserve-3d;
        }

        .bingo-tile.marked .tile-inner {
            transform: rotateY(180deg);
        }

        .tile-front, .tile-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 10px;
            word-wrap: break-word;
            overflow: hidden;
        }

        .tile-front {
            background: white;
            border: 3px solid #3498db;
            color: #333;
        }

        .tile-back {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            border: 3px solid #229954;
            color: white;
            transform: rotateY(180deg);
        }

        .bingo-tile.placeholder {
            pointer-events: none;
        }

        .bingo-tile.placeholder .tile-inner {
            background: transparent;
            border-radius: 10px;
            border: none;
        }

        .bingo-tile:not(.empty):hover .tile-inner {
            transform: rotateY(15deg);
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
        }

        .bingo-tile.marked:not(.empty):hover .tile-inner {
            transform: rotateY(165deg);
        }

        @keyframes spiralIn {
            0% {
                transform: scale(0) rotate(-360deg);
                opacity: 0;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .bingo-tile.spiral-in .tile-inner {
            animation: spiralIn var(--spiral-in-duration) ease-out;
        }

        /* CHAOTIC DESTRUCTION PARTICLES */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
        }

        .particle.chaos {
            background: var(--particle-color);
            box-shadow: 0 0 3px var(--particle-glow);
        }

        @keyframes violentDestruction {
            0% {
                transform: translate(var(--start-x), var(--start-y)) 
                           scale(var(--start-scale)) 
                           rotateX(var(--rot-x-start)) 
                           rotateY(var(--rot-y-start)) 
                           rotateZ(var(--rot-z-start));
                opacity: var(--start-opacity);
            }
            100% {
                transform: translate(var(--end-x), var(--end-y)) 
                           scale(0) 
                           rotateX(var(--rot-x-end)) 
                           rotateY(var(--rot-y-end)) 
                           rotateZ(var(--rot-z-end));
                opacity: 0;
            }
        }

        .particle.chaos {
            animation: violentDestruction var(--particle-duration) var(--particle-easing) forwards;
        }

        .card-fragment {
            pointer-events: none;
            z-index: 1000;
            will-change: transform;
        }

        .tile-back::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tile-back::after {
            content: 'âœ“';
            position: absolute;
            top: 3px;
            right: 8px;
            font-size: 16px;
            color: white;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            .bingo-tile {
                font-size: 11px;
            }

            .tile-front, .tile-back {
                padding: 5px;
            }

            .bingo-container {
                gap: 5px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Items to Use</h3>
        <div class="control-row">
            <button class="control-btn" onclick="decreaseItems()">-</button>
            <span class="item-count" id="itemCount">25</span>
            <button class="control-btn" onclick="increaseItems()">+</button>
        </div>
        <button class="shuffle-btn" onclick="shuffleBoard()"><span>ðŸ”€</span><span>Shuffle</span></button>
    </div>
    
    <h1>ðŸŽ­ Puer Aeternus Bingo</h1>
    <div class="bingo-container" id="bingoBoard"></div>
    
    <div id="particleSandbox" style="position: fixed; inset: 0; overflow: hidden; pointer-events: none; z-index: 9999;"></div>

    <script>
        // ============================================================
        // MASTER CONFIGURATION - Everything in one place, capisce?
        // ============================================================
        const TIMINGS = {
            flipDuration: 600,
            minRipDuration: 1000,
            maxRipDuration: 1200,
            spiralInDuration: 500,
            flipbackWait: 300,
            maxStaggerDelay: 200,
            debounceDelay: 100,
            minPlaceholderDisplay: 500
        };

        const PARTICLE_CONFIG = {
            chaos: {
                count: 30,
                minSize: 4,
                maxSize: 8,
                minDuration: 500,
                maxDuration: 1050,
                maxStartDelay: 60,
                spawnRadiusMultiplier: 0.85,
                angleVariationRad: 0.8,
                overshootMinMult: 0.5,
                overshootMaxMult: 4,
                rotationMin: -720,
                rotationMax: 720,
                startScaleMin: 0.7,
                startScaleMax: 1.3,
                startOpacityMin: 0.7,
                startOpacityMax: 1.0,
                colors: [
                    { bg: 'rgba(20, 20, 35, 0.9)', glow: 'rgba(40, 40, 80, 0.5)' },
                    { bg: 'rgba(30, 25, 40, 0.85)', glow: 'rgba(50, 40, 70, 0.4)' },
                    { bg: 'rgba(15, 15, 25, 0.95)', glow: 'rgba(30, 30, 50, 0.6)' },
                    { bg: 'rgba(25, 20, 45, 0.8)', glow: 'rgba(60, 50, 90, 0.3)' },
                    { bg: 'rgba(40, 50, 80, 0.7)', glow: 'rgba(70, 90, 130, 0.4)' }
                ],
                easingFunctions: ['ease-in', 'ease-out', 'linear', 'ease-in-out']
            }
        };
        
        const RIP_CONFIG = {
            jitter: 8,
            vortex: {
                spiralDirection: 1,
                // Fragment rotation speed RELATIVE to orbital motion (degrees per second)
                // 0 = maintains orientation toward center as it orbits (natural)
                // Positive = spins faster than orbit (spins "with" the vortex)
                // Negative = spins slower than orbit (spins "against" the vortex)
                relativeRotationSpeedMin: -30,
                relativeRotationSpeedMax: 70,
                fragmentRotationVariation: 30,
                
                // Spiral/orbital speed (revolutions per second around center)
                orbitalSpeedMin: 0.7,
                orbitalSpeedMax: 0.8,
                fragmentOrbitVariation: 0.1,
                
                // Don't go ALL the way to center - leave a gap
                centerGapPercent: 0.1,

                opacityStart: 0.7, // when to start fading (0=start, 1=end)

                // Acceleration curve - controls how fast it speeds up
                // 1 = linear (constant speed)
                // 2 = quadratic (gentle acceleration)
                // 3 = cubic (strong acceleration)
                // 1.5 = sweet spot between gentle and strong
                easePower: 2,
                
                // Number of keyframes for smooth spiral
                spiralKeyframes: 32,
            }
        };

        function initCSSVariables() {
            const root = document.documentElement;
            root.style.setProperty('--flip-duration', `${TIMINGS.flipDuration}ms`);
            root.style.setProperty('--rip-duration', `${TIMINGS.maxRipDuration}ms`);
            root.style.setProperty('--spiral-in-duration', `${TIMINGS.spiralInDuration}ms`);
        }

        window.TIMINGS = TIMINGS;
        window.PARTICLE_CONFIG = PARTICLE_CONFIG;
        window.refreshCSSTimings = initCSSVariables;
        initCSSVariables();

        const DEFAULT_ITEMS = `Free Space
Coffee Break
Meeting Runs Late
Technical Difficulties
Someone's On Mute
Can You See My Screen?
Sorry, Go Ahead
Email Could've Been
Let's Circle Back
Moving Forward
Synergy
Low Hanging Fruit
Think Outside Box
Touch Base
On My Radar
Bandwidth
Deep Dive
Loop You In
Take This Offline
Action Items
Best Practices
Leverage
Paradigm Shift
Win-Win
Game Changer
At The End Of Day
Reach Out
Ping Me
Circle Back Around
Let's Take This Async
Parking Lot
Quick Sync
Align On This
Get Ducks In Row
Run It Up Flagpole
Boil The Ocean
Move The Needle
Drink The Kool-Aid
Peel The Onion
Push The Envelope`.split('\n').map(item => item.trim());

        let currentItemCount = 25;
        let availableItems = [];
        let rebuildTimeout = null;
        let isBuilding = false;
        let itemsLoadedOnce = false;

        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getNextSquare(num) {
            const sqrt = Math.ceil(Math.sqrt(num));
            return sqrt * sqrt;
        }

        function calculateStaggerDelay(index, totalTiles) {
            return Math.floor(((index + 1) / totalTiles) * TIMINGS.maxStaggerDelay);
        }

        function randomInRange(min, max) {
            return min + Math.random() * (max - min);
        }

        function pointsToPolygon(points) {
            return `polygon(${points.map(p => `${p.x}% ${p.y}%`).join(', ')})`;
        }

        function calculatePolygonCentroid(points) {
            if (points.length < 3) {
                console.warn('using fallback centroid');
                return { x: 50, y: 50 };
            }
            
            // Calculate centroid using the proper formula - no shortcuts!
            let area = 0;
            let cx = 0;
            let cy = 0;
            
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                const cross = points[i].x * points[j].y - points[j].x * points[i].y;
                area += cross;
                cx += (points[i].x + points[j].x) * cross;
                cy += (points[i].y + points[j].y) * cross;
            }
            
            area *= 0.5;
            cx /= (6 * area);
            cy /= (6 * area);
            
            return { x: cx, y: cy };
        }

        // ============================================================
        // CARD RIPPING EFFECT - Trifold tear from center
        // ============================================================
        function createCardRip(tile) {
            const rect = tile.getBoundingClientRect();
            const sandbox = document.getElementById('particleSandbox');
            const vortex = RIP_CONFIG.vortex;
            
            const isFlipped = tile.classList.contains('marked');
            const sourceElement = isFlipped ? 
                tile.querySelector('.tile-back') : 
                tile.querySelector('.tile-front');
            
            if (!sourceElement) return;
            
            tile.style.opacity = '0';
            
            const width = rect.width;
            const height = rect.height;
            const jitter = RIP_CONFIG.jitter;
            
            // Pick a random rotation - keep 'em on their toes!
            const rotations = [0, 90, 180, 270];
            const rotation = rotations[Math.floor(Math.random() * rotations.length)];
            
            // Define the 5 shared cut points with randomization - as NUMBERS, not strings!
            const tlX = randomInRange(-jitter, jitter);
            const tlY = randomInRange(-jitter, jitter);
            const trX = 100 + randomInRange(-jitter, jitter);
            const trY = randomInRange(-jitter, jitter);
            const centerX = 50 + randomInRange(-jitter, jitter);
            const centerY = 66.666 + randomInRange(-jitter, jitter);
            const bcX = 50 + randomInRange(-jitter, jitter);
            const bcY = 100;
            
            const fragment1Points = [
                { x: 0, y: 0 },
                { x: tlX, y: tlY },
                { x: centerX, y: centerY },
                { x: bcX, y: bcY },
                { x: 0, y: 100 }
            ];
            
            const fragment2Points = [
                { x: centerX, y: centerY },
                { x: trX, y: trY },
                { x: 100, y: 0 },
                { x: 100, y: 100 },
                { x: bcX, y: bcY }
            ];
            
            const fragment3Points = [
                { x: 0, y: 0 },
                { x: tlX, y: tlY },
                { x: centerX, y: centerY },
                { x: trX, y: trY },
                { x: 100, y: 0 }
            ];
            
            // Create fragments and set their clip paths
            const fragment1 = createFragment(sourceElement, rect, isFlipped);
            fragment1.style.clipPath = pointsToPolygon(fragment1Points);
            
            const fragment2 = createFragment(sourceElement, rect, isFlipped);
            fragment2.style.clipPath = pointsToPolygon(fragment2Points);
            
            const fragment3 = createFragment(sourceElement, rect, isFlipped);
            fragment3.style.clipPath = pointsToPolygon(fragment3Points);
            
            const centroid1 = calculatePolygonCentroid(fragment1Points);
            const centroid2 = calculatePolygonCentroid(fragment2Points);
            const centroid3 = calculatePolygonCentroid(fragment3Points);
            
            const fragments = [fragment1, fragment2, fragment3];
            
            // Set up each fragment with its center of gravity and vortex parameters
            const fragmentData = [
                { fragment: fragment1, centroid: centroid1 },
                { fragment: fragment2, centroid: centroid2 },
                { fragment: fragment3, centroid: centroid3 }
            ];
            
            // Calculate the ACTUAL center of the card in screen coordinates
            const cardCenterX = rect.left + rect.width / 2;
            const cardCenterY = rect.top + rect.height / 2;
            
            const fragmentDuration = randomInRange(TIMINGS.minRipDuration, TIMINGS.maxRipDuration);
            const durationInSeconds = fragmentDuration / 1000;

            const cardOrbitalSpeed = randomInRange(vortex.orbitalSpeedMin, vortex.orbitalSpeedMax);

            // User-specified rotation is ADDED to the natural rotation
            const cardRelativeRotationSpeed = randomInRange(
                vortex.relativeRotationSpeedMin,
                vortex.relativeRotationSpeedMax
            );
            
            fragmentData.forEach(({ fragment, centroid }) => {
                // Transform origin is THE CENTROID
                fragment.style.transformOrigin = `${centroid.x}% ${centroid.y}%`;
                
                // Calculate where the fragment's centroid actually IS in screen coords
                const fragmentCenterX = rect.left + (rect.width * centroid.x / 100);
                const fragmentCenterY = rect.top + (rect.height * centroid.y / 100);
                
                // Vector from fragment to card center
                const toCenterX = cardCenterX - fragmentCenterX;
                const toCenterY = cardCenterY - fragmentCenterY;
                const distance = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
                
                // Starting angle - this is where the fragment IS relative to center
                // CRITICAL: It's the OPPOSITE of the vector TO center!
                const startAngle = Math.atan2(-toCenterY, -toCenterX);
                
                // Calculate actual motion based on SPEED and DURATION
                // This is the KEY - now duration and speed are INDEPENDENT!
                const orbitalSpeed = cardOrbitalSpeed + randomInRange(-vortex.fragmentOrbitVariation, vortex.fragmentOrbitVariation);
                const totalRevolutions = orbitalSpeed * durationInSeconds;
                const totalRotation = totalRevolutions * Math.PI * 2 * vortex.spiralDirection;
                
                // Don't go all the way to center - leave a gap
                const finalDistance = distance * vortex.centerGapPercent;
                
                // rotation RELATIVE to the spiral!
                // When you orbit, you're already rotating just to face the center
                // The "natural" rotation speed is exactly the orbital speed
                const naturalRotationSpeed = orbitalSpeed * 360 * vortex.spiralDirection; // deg/sec
                
                const relativeRotationSpeed = cardRelativeRotationSpeed + randomInRange(-vortex.fragmentRotationVariation, vortex.fragmentRotationVariation);
                
                // Total rotation = natural (to maintain orientation) + relative (extra spin)
                const actualRotationSpeed = naturalRotationSpeed + relativeRotationSpeed;
                const totalFragmentSpin = actualRotationSpeed * durationInSeconds;
                
                // Generate keyframes along a REAL spiral path!
                const keyframes = [];
                const numSteps = vortex.spiralKeyframes;
                
                const easeIn = (t) => Math.pow(t, vortex.easePower);
                
                for (let i = 0; i <= numSteps; i++) {
                    const t = i / numSteps;  // 0 to 1, linear progression through time
                    const t_eased = easeIn(t);  // 0 to 1, but ACCELERATING
                    
                    // Use EASED t for the inward motion - starts slow, ends FAST!
                    const currentDistance = distance - (distance - finalDistance) * t_eased;
                    const currentAngle = startAngle + totalRotation * t_eased;
                    
                    // Convert polar to cartesian (relative to CARD center)
                    const x_card = Math.cos(currentAngle) * currentDistance;
                    const y_card = Math.sin(currentAngle) * currentDistance;
                    
                    // Convert to fragment-centered coordinates - THIS IS THE KEY!
                    const x = x_card + toCenterX;
                    const y = y_card + toCenterY;
                    
                    // Smooth rotation and scale - use EASED t here too
                    const currentRotation = totalFragmentSpin * t_eased;
                    const currentScale = 1 - t_eased;  // Shrink to 0
                    
                    // Opacity - fade LATE, not early! Keep it visible longer!
                    let currentOpacity = 1;
                    if (t > vortex.opacityStart) {
                        const fadeProgress = (t - vortex.opacityStart) / (1 - vortex.opacityStart);
                        currentOpacity = 1 - fadeProgress;
                    }
                    
                    keyframes.push({
                        transform: `translate(${x}px, ${y}px) rotate(${currentRotation}deg) scale(${currentScale})`,
                        opacity: currentOpacity
                    });
                }
                
                sandbox.appendChild(fragment);
                
                // Use Web Animations API for smooth spiral - this is the REAL deal!
                requestAnimationFrame(() => {
                    fragment.animate(keyframes, {
                        duration: fragmentDuration,  // Each fragment gets its OWN timing!
                        easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)',
                        fill: 'forwards'
                    });
                });
            });
            
            setTimeout(() => {
                fragments.forEach(f => f.remove());
            }, TIMINGS.maxRipDuration);
        }
        
        function createFragment(sourceElement, rect, isFlipped) {
            const fragment = document.createElement('div');
            fragment.className = 'card-fragment';
            
            const computedStyle = window.getComputedStyle(sourceElement);
            fragment.style.position = 'absolute';
            fragment.style.left = rect.left + 'px';
            fragment.style.top = rect.top + 'px';
            fragment.style.width = rect.width + 'px';
            fragment.style.height = rect.height + 'px';
            fragment.style.background = computedStyle.background;
            fragment.style.border = computedStyle.border;
            fragment.style.borderRadius = computedStyle.borderRadius;
            fragment.style.color = computedStyle.color;
            fragment.style.fontSize = computedStyle.fontSize;
            fragment.style.fontWeight = computedStyle.fontWeight;
            fragment.style.display = 'flex';
            fragment.style.alignItems = 'center';
            fragment.style.justifyContent = 'center';
            fragment.style.textAlign = 'center';
            fragment.style.padding = computedStyle.padding;
            fragment.textContent = sourceElement.textContent;
            
            return fragment;
        }
        
        // ============================================================
        // CHAOTIC DESTRUCTION PARTICLE SYSTEM
        // ============================================================
        function createChaoticDestruction(tile) {
            const rect = tile.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const tileSize = Math.min(rect.width, rect.height);
            const config = PARTICLE_CONFIG.chaos;
            
            const particles = [];
            const spawnRadius = tileSize * config.spawnRadiusMultiplier;
            const sandbox = document.getElementById('particleSandbox');
            
            const maxParticleLifetime = config.maxStartDelay + config.maxDuration;
            
            for (let i = 0; i < config.count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle chaos';
                
                const size = randomInRange(config.minSize, config.maxSize);
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                const colorData = config.colors[Math.floor(Math.random() * config.colors.length)];
                particle.style.setProperty('--particle-color', colorData.bg);
                particle.style.setProperty('--particle-glow', colorData.glow);
                
                const angle = Math.random() * Math.PI * 2;
                const spawnDist = spawnRadius * randomInRange(0.3, 1.0);
                const startX = Math.cos(angle) * spawnDist;
                const startY = Math.sin(angle) * spawnDist;
                
                const targetAngle = angle + (Math.random() - 0.5) * Math.PI * config.angleVariationRad;
                const overshoot = randomInRange(config.overshootMinMult, config.overshootMaxMult);
                const endDist = -spawnDist * overshoot;
                const endX = Math.cos(targetAngle) * endDist;
                const endY = Math.sin(targetAngle) * endDist;
                
                const rotXStart = Math.random() * 360;
                const rotYStart = Math.random() * 360;
                const rotZStart = Math.random() * 360;
                const rotXEnd = rotXStart + randomInRange(config.rotationMin, config.rotationMax);
                const rotYEnd = rotYStart + randomInRange(config.rotationMin, config.rotationMax);
                const rotZEnd = rotZStart + randomInRange(config.rotationMin, config.rotationMax);
                
                const duration = randomInRange(config.minDuration, config.maxDuration);
                const easing = config.easingFunctions[Math.floor(Math.random() * config.easingFunctions.length)];
                const startScale = randomInRange(config.startScaleMin, config.startScaleMax);
                const startOpacity = randomInRange(config.startOpacityMin, config.startOpacityMax);
                
                particle.style.left = `${centerX}px`;
                particle.style.top = `${centerY}px`;
                particle.style.setProperty('--start-x', `${startX}px`);
                particle.style.setProperty('--start-y', `${startY}px`);
                particle.style.setProperty('--end-x', `${endX}px`);
                particle.style.setProperty('--end-y', `${endY}px`);
                particle.style.setProperty('--rot-x-start', `${rotXStart}deg`);
                particle.style.setProperty('--rot-y-start', `${rotYStart}deg`);
                particle.style.setProperty('--rot-z-start', `${rotZStart}deg`);
                particle.style.setProperty('--rot-x-end', `${rotXEnd}deg`);
                particle.style.setProperty('--rot-y-end', `${rotYEnd}deg`);
                particle.style.setProperty('--rot-z-end', `${rotZEnd}deg`);
                particle.style.setProperty('--start-scale', startScale);
                particle.style.setProperty('--start-opacity', startOpacity);
                particle.style.setProperty('--particle-duration', `${duration}ms`);
                particle.style.setProperty('--particle-easing', easing);
                
                const startDelay = Math.random() * config.maxStartDelay;
                particle.style.animationDelay = `${startDelay}ms`;
                
                sandbox.appendChild(particle);
                particles.push(particle);
            }
            
            setTimeout(() => {
                particles.forEach(p => p.remove());
            }, maxParticleLifetime);
        }

        // ============================================================
        // USER INTERACTION HANDLERS
        // ============================================================

        function increaseItems() {
            if (currentItemCount < availableItems.length) {
                currentItemCount++;
                document.getElementById('itemCount').textContent = currentItemCount;
                debouncedRefresh();
            }
        }

        function decreaseItems() {
            if (currentItemCount > 1) {
                currentItemCount--;
                document.getElementById('itemCount').textContent = currentItemCount;
                debouncedRefresh();
            }
        }

        function shuffleBoard() {
            refreshBoard();
        }

        function debouncedRefresh() {
            if (rebuildTimeout) {
                clearTimeout(rebuildTimeout);
            }
            
            rebuildTimeout = setTimeout(() => {
                refreshBoard();
            }, TIMINGS.debounceDelay);
        }

        // ============================================================
        // BOARD REFRESH ANIMATION SEQUENCE
        // ============================================================

        function refreshBoard() {
            if (isBuilding) return;
            
            isBuilding = true;
            const board = document.getElementById('bingoBoard');
            const tiles = board.querySelectorAll('.bingo-tile');
            
            let hadFlippedCards = false;
            tiles.forEach(tile => {
                if (tile.classList.contains('marked')) {
                    hadFlippedCards = true;
                    tile.classList.remove('marked');
                }
            });
            
            const flipBackDelay = hadFlippedCards ? TIMINGS.flipbackWait : 0;
            setTimeout(() => {
                tiles.forEach((tile, index) => {
                    setTimeout(() => {
                        createCardRip(tile);
                        if (!tile.classList.contains('placeholder') && !tile.classList.contains('empty')) {
                            createChaoticDestruction(tile);
                        }
                    }, calculateStaggerDelay(index, tiles.length));
                });
            }, flipBackDelay);
            
            const lastTileDelay = calculateStaggerDelay(tiles.length - 1, tiles.length);
            const maxParticleLifetime = PARTICLE_CONFIG.chaos.maxStartDelay + PARTICLE_CONFIG.chaos.maxDuration;
            const maxAnimationDuration = Math.max(TIMINGS.maxRipDuration, maxParticleLifetime);
            const totalWaitTime = flipBackDelay + lastTileDelay + maxAnimationDuration;
            
            setTimeout(() => {
                renderPlaceholders();
                
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        populateBoard();
                    });
                });
            }, totalWaitTime);
        }

        // ============================================================
        // BOARD RENDERING
        // ============================================================

        async function loadItemsOnce() {
            if (itemsLoadedOnce) {
                return;
            }
            
            let source = 'default items';
            try {
                const response = await fetch('items.txt');
                if (response.ok) {
                    const text = await response.text();
                    const fileItems = text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0);
                    
                    if (fileItems.length > 0) {
                        availableItems = fileItems;
                        source = 'items.txt';
                    } else {
                        availableItems = [...DEFAULT_ITEMS];
                    }
                } else {
                    availableItems = [...DEFAULT_ITEMS];
                }
            } catch (error) {
                availableItems = [...DEFAULT_ITEMS];
            }
            
            itemsLoadedOnce = true;
            console.log(`Loaded ${availableItems.length} items from ${source}`);
        }

        function renderPlaceholders() {
            const board = document.getElementById('bingoBoard');
            
            const targetSize = getNextSquare(currentItemCount);
            const gridSize = Math.sqrt(targetSize);
            
            board.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            
            board.innerHTML = '';
            for (let i = 0; i < targetSize; i++) {
                const tile = document.createElement('div');
                tile.className = 'bingo-tile placeholder';
                const inner = document.createElement('div');
                inner.className = 'tile-inner';
                tile.appendChild(inner);
                board.appendChild(tile);
            }
        }
        
        async function populateBoard() {
            const board = document.getElementById('bingoBoard');
            const startTime = performance.now();
            
            const minAnimTime = new Promise(resolve => 
                setTimeout(resolve, TIMINGS.minPlaceholderDisplay)
            );
            
            const itemsPromise = loadItemsOnce();
            
            await Promise.all([minAnimTime, itemsPromise]);
            
            const loadTime = Math.round(performance.now() - startTime);
            console.log(`Board ready after ${loadTime}ms`);
            
            if (currentItemCount > availableItems.length) {
                currentItemCount = availableItems.length;
            }
            document.getElementById('itemCount').textContent = currentItemCount;
            
            const allItems = availableItems.slice(0, currentItemCount);
            
            const targetSize = getNextSquare(allItems.length);
            const gridSize = Math.sqrt(targetSize);
            
            const items = [...allItems];
            while (items.length < targetSize) {
                items.push('');
            }
            
            const shuffled = shuffle(items);
            
            const tiles = board.querySelectorAll('.bingo-tile');
            shuffled.forEach((item, index) => {
                if (tiles[index]) {
                    const tile = tiles[index];
                    tile.className = 'bingo-tile';
                    
                    const inner = document.createElement('div');
                    inner.className = 'tile-inner';
                    
                    inner.style.transform = 'scale(0) rotate(-360deg)';
                    inner.style.opacity = '0';
                    
                    const front = document.createElement('div');
                    front.className = 'tile-front';
                    front.textContent = item;
                    
                    const back = document.createElement('div');
                    back.className = 'tile-back';
                    back.textContent = item;
                    
                    inner.appendChild(front);
                    inner.appendChild(back);
                    tile.innerHTML = '';
                    tile.appendChild(inner);
                    
                    if (item) {
                        tile.onclick = function() {
                            this.classList.toggle('marked');
                        };
                    } else {
                        tile.classList.add('empty');
                        tile.style.opacity = '0.3';
                        tile.style.cursor = 'default';
                        front.style.border = '3px dashed #95a5a6';
                        tile.onclick = null;
                    }
                }
            });
            
            board.offsetHeight;
            
            tiles.forEach((tile, index) => {
                const inner = tile.querySelector('.tile-inner');
                if (!inner) return;
                
                const delay = calculateStaggerDelay(index, tiles.length);
                
                setTimeout(() => {
                    inner.style.transform = '';
                    inner.style.opacity = '';
                    tile.classList.add('spiral-in');
                    
                    setTimeout(() => {
                        tile.classList.remove('spiral-in');
                    }, TIMINGS.spiralInDuration);
                }, delay);
            });
            
            isBuilding = false;
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================

        async function initBoard() {
            renderPlaceholders();
            await populateBoard();
        }

        initBoard();
    </script>
</body>
</html>
