<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puer Aeternus Bingo</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text x=%22-.15em%22 y=%22.9em%22 font-size=%2290%22>ðŸŽ­</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            padding-top: 80px;
        }

        h1 {
            color: white;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            position: relative;
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 150px;
        }

        .controls h3 {
            margin: 0;
            font-size: 14px;
            color: #2c3e50;
            text-align: center;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .control-btn {
            background: #3498db;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #2980b9;
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .item-count {
            font-size: 16px;
            font-weight: bold;
            color: #2c3e50;
            min-width: 40px;
            text-align: center;
        }

        .shuffle-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shuffle-btn:hover {
            background: #229954;
            transform: translateY(-1px);
        }

        .shuffle-btn:active {
            transform: translateY(0);
        }

        .bingo-container {
            display: grid;
            gap: 10px;
            max-width: 800px;
            min-width: 0;
            width: 100%;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            overflow: hidden;
            position: relative;
        }

        .bingo-tile {
            aspect-ratio: 1;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            user-select: none;
            position: relative;
            min-width: 0;
            min-height: 0;
            perspective: 1000px;
        }

        .tile-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform var(--flip-duration);
            transform-style: preserve-3d;
        }

        .bingo-tile.marked .tile-inner {
            transform: rotateY(180deg);
        }

        .tile-front, .tile-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 10px;
            word-wrap: break-word;
            overflow: hidden;
        }

        .tile-front {
            background: white;
            border: 3px solid #3498db;
            color: #333;
        }

        .tile-back {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            border: 3px solid #229954;
            color: white;
            transform: rotateY(180deg);
        }

        .bingo-tile.placeholder {
            pointer-events: none;
        }

        .bingo-tile.placeholder .tile-inner {
            background: transparent;
            border-radius: 10px;
            border: none;
        }

        .bingo-tile:not(.empty):hover .tile-inner {
            transform: rotateY(15deg);
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
        }

        .bingo-tile.marked:not(.empty):hover .tile-inner {
            transform: rotateY(165deg);
        }

        @keyframes spiralOut {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes spiralIn {
            0% {
                transform: scale(0) rotate(-360deg);
                opacity: 0;
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        .bingo-tile.spiral-out .tile-inner {
            animation: spiralOut var(--spiral-out-duration) ease-in-out forwards;
        }

        .bingo-tile.spiral-in .tile-inner {
            animation: spiralIn var(--spiral-in-duration) ease-out;
        }

        .tile-back::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tile-back::after {
            content: 'âœ“';
            position: absolute;
            top: 3px;
            right: 8px;
            font-size: 16px;
            color: white;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            .bingo-tile {
                font-size: 11px;
            }

            .tile-front, .tile-back {
                padding: 5px;
            }

            .bingo-container {
                gap: 5px;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Items to Use</h3>
        <div class="control-row">
            <button class="control-btn" onclick="decreaseItems()">-</button>
            <span class="item-count" id="itemCount">25</span>
            <button class="control-btn" onclick="increaseItems()">+</button>
        </div>
        <button class="shuffle-btn" onclick="shuffleBoard()">ðŸ”€ Shuffle</button>
    </div>
    
    <h1>ðŸŽ­ Puer Aeternus Bingo</h1>
    <div class="bingo-container" id="bingoBoard"></div>

    <script>
        // ============================================================
        // TIMING CONFIGURATION - Single source of truth, capisce?
        // ============================================================
        const TIMINGS = {
            // CSS Animation durations (in milliseconds)
            flipDuration: 600,          // How long the card flip takes
            spiralOutDuration: 600,     // How long tiles spiral out
            spiralInDuration: 500,      // How long tiles spiral in
            shimmerDuration: 1500,      // Placeholder shimmer effect
            
            // JavaScript timing values (in milliseconds)
            flipbackWait: 300,          // Wait time before starting spiral out (if cards were flipped)
            maxStaggerDelay: 200,       // Maximum delay for staggered animations
            debounceDelay: 100,         // Debounce delay for rapid button clicks
            spiralCompleteBuffer: 600,  // Extra time to ensure spiral completes
            minPlaceholderDisplay: 500  // Minimum time to show placeholder animation (for that professional look)
        };

        // Inject timing values into CSS custom properties
        function initCSSVariables() {
            const root = document.documentElement;
            root.style.setProperty('--flip-duration', `${TIMINGS.flipDuration}ms`);
            root.style.setProperty('--spiral-out-duration', `${TIMINGS.spiralOutDuration}ms`);
            root.style.setProperty('--spiral-in-duration', `${TIMINGS.spiralInDuration}ms`);
            root.style.setProperty('--shimmer-duration', `${TIMINGS.shimmerDuration}ms`);
        }

        // Make TIMINGS available in console for live tweaking
        // Usage: TIMINGS.flipDuration = 1000; initCSSVariables();
        window.TIMINGS = TIMINGS;
        window.refreshCSSTimings = initCSSVariables;

        // Initialize CSS variables on load
        initCSSVariables();

        // ============================================================
        // APPLICATION STATE
        // ============================================================
        const DEFAULT_ITEMS = `Free Space
Coffee Break
Meeting Runs Late
Technical Difficulties
Someone's On Mute
Can You See My Screen?
Sorry, Go Ahead
Email Could've Been
Let's Circle Back
Moving Forward
Synergy
Low Hanging Fruit
Think Outside Box
Touch Base
On My Radar
Bandwidth
Deep Dive
Loop You In
Take This Offline
Action Items
Best Practices
Leverage
Paradigm Shift
Win-Win
Game Changer
At The End Of Day
Reach Out
Ping Me
Circle Back Around
Let's Take This Async
Parking Lot
Quick Sync
Align On This
Get Ducks In Row
Run It Up Flagpole
Boil The Ocean
Move The Needle
Drink The Kool-Aid
Peel The Onion
Push The Envelope`.split('\n').map(item => item.trim());

        let currentItemCount = 25;
        let availableItems = [];
        let rebuildTimeout = null;
        let isBuilding = false;
        let itemsLoadedOnce = false;  // Track if we've already fetched items.txt

        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================
        
        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getNextSquare(num) {
            const sqrt = Math.ceil(Math.sqrt(num));
            return sqrt * sqrt;
        }

        function calculateStaggerDelay(index, totalTiles) {
            return Math.floor(((index + 1) / totalTiles) * TIMINGS.maxStaggerDelay);
        }

        // ============================================================
        // USER INTERACTION HANDLERS
        // ============================================================

        function increaseItems() {
            if (currentItemCount < availableItems.length) {
                currentItemCount++;
                document.getElementById('itemCount').textContent = currentItemCount;
                debouncedRefresh();
            }
        }

        function decreaseItems() {
            if (currentItemCount > 1) {
                currentItemCount--;
                document.getElementById('itemCount').textContent = currentItemCount;
                debouncedRefresh();
            }
        }

        function shuffleBoard() {
            refreshBoard();
        }

        function debouncedRefresh() {
            if (rebuildTimeout) {
                clearTimeout(rebuildTimeout);
            }
            
            rebuildTimeout = setTimeout(() => {
                refreshBoard();
            }, TIMINGS.debounceDelay);
        }

        // ============================================================
        // BOARD REFRESH ANIMATION SEQUENCE
        // ============================================================

        function refreshBoard() {
            if (isBuilding) return;
            
            isBuilding = true;
            const board = document.getElementById('bingoBoard');
            const tiles = board.querySelectorAll('.bingo-tile');
            
            // Step 1: Flip all marked cards back
            let hadFlippedCards = false;
            tiles.forEach(tile => {
                if (tile.classList.contains('marked')) {
                    hadFlippedCards = true;
                    tile.classList.remove('marked');
                }
            });
            
            // Step 2: Spiral out effect with stagger
            const spiralOutDelay = hadFlippedCards ? TIMINGS.flipbackWait : 0;
            setTimeout(() => {
                tiles.forEach((tile, index) => {
                    setTimeout(() => {
                        tile.classList.add('spiral-out');
                    }, calculateStaggerDelay(index, tiles.length));
                });
            }, spiralOutDelay);
            
            // Step 3: Clear and show placeholders, then spiral in new tiles
            const lastTileDelay = calculateStaggerDelay(tiles.length - 1, tiles.length);
            // Wait for: flipback delay + last tile starts + spiral animation completes
            const totalWaitTime = spiralOutDelay + lastTileDelay + TIMINGS.spiralOutDuration + 100;
            
            setTimeout(() => {
                renderPlaceholders();
                
                // Double RAF for clean render
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        populateBoard();
                    });
                });
            }, totalWaitTime);
        }

        // ============================================================
        // BOARD RENDERING
        // ============================================================

        // Load items from file - but only ONCE, capisce?
        async function loadItemsOnce() {
            // Already got the goods? Fuggedaboutit!
            if (itemsLoadedOnce) {
                return;
            }
            
            let source = 'default items';
            try {
                const response = await fetch('items.txt');
                if (response.ok) {
                    const text = await response.text();
                    const fileItems = text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0);
                    
                    if (fileItems.length > 0) {
                        availableItems = fileItems;
                        source = 'items.txt';
                    } else {
                        availableItems = [...DEFAULT_ITEMS];
                    }
                } else {
                    availableItems = [...DEFAULT_ITEMS];
                }
            } catch (error) {
                availableItems = [...DEFAULT_ITEMS];
            }
            
            itemsLoadedOnce = true;
            console.log(`Loaded ${availableItems.length} items from ${source} (one time only, baby!)`);
        }

        function renderPlaceholders() {
            const board = document.getElementById('bingoBoard');
            
            const targetSize = getNextSquare(currentItemCount);
            const gridSize = Math.sqrt(targetSize);
            
            board.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            
            board.innerHTML = '';
            // Create invisible skeleton tiles to maintain grid structure
            for (let i = 0; i < targetSize; i++) {
                const tile = document.createElement('div');
                tile.className = 'bingo-tile placeholder';
                const inner = document.createElement('div');
                inner.className = 'tile-inner';
                tile.appendChild(inner);
                board.appendChild(tile);
            }
        }
        
        async function populateBoard() {
            const board = document.getElementById('bingoBoard');
            const startTime = performance.now();
            
            // Promise 1: Minimum animation time - gotta let people appreciate the show!
            const minAnimTime = new Promise(resolve => 
                setTimeout(resolve, TIMINGS.minPlaceholderDisplay)
            );
            
            // Promise 2: Load items (only first time, after that it's instant)
            const itemsPromise = loadItemsOnce();
            
            // Wait for BOTH - the slower one sets the pace, capisce?
            await Promise.all([minAnimTime, itemsPromise]);
            
            const loadTime = Math.round(performance.now() - startTime);
            console.log(`Board ready after ${loadTime}ms (minimum was ${TIMINGS.minPlaceholderDisplay}ms)`);
            
            // Ensure item count doesn't exceed available items
            if (currentItemCount > availableItems.length) {
                currentItemCount = availableItems.length;
            }
            document.getElementById('itemCount').textContent = currentItemCount;
            
            const allItems = availableItems.slice(0, currentItemCount);
            
            const targetSize = getNextSquare(allItems.length);
            const gridSize = Math.sqrt(targetSize);
            console.log(`Creating ${gridSize}x${gridSize} board (${targetSize} tiles total)`);
            
            // Pad items array with empty strings to fill grid
            const items = [...allItems];
            while (items.length < targetSize) {
                items.push('');
            }
            
            const shuffled = shuffle(items);
            
            // Fill existing placeholder tiles with real content
            const tiles = board.querySelectorAll('.bingo-tile');
            shuffled.forEach((item, index) => {
                if (tiles[index]) {
                    const tile = tiles[index];
                    tile.className = 'bingo-tile';
                    
                    const inner = document.createElement('div');
                    inner.className = 'tile-inner';
                    
                    // Set initial state INLINE to prevent flash - start invisible!
                    inner.style.transform = 'scale(0) rotate(-360deg)';
                    inner.style.opacity = '0';
                    
                    const front = document.createElement('div');
                    front.className = 'tile-front';
                    front.textContent = item;
                    
                    const back = document.createElement('div');
                    back.className = 'tile-back';
                    back.textContent = item;
                    
                    inner.appendChild(front);
                    inner.appendChild(back);
                    tile.innerHTML = '';
                    tile.appendChild(inner);
                    
                    if (item) {
                        tile.onclick = function() {
                            this.classList.toggle('marked');
                        };
                    } else {
                        tile.classList.add('empty');
                        tile.style.opacity = '0.3';
                        tile.style.cursor = 'default';
                        front.style.border = '3px dashed #95a5a6';
                        tile.onclick = null;
                    }
                }
            });
            
            // Force reflow so browser registers the inline styles
            board.offsetHeight;
            
            // NOW trigger spiral-in animation on all tiles
            tiles.forEach((tile, index) => {
                const inner = tile.querySelector('.tile-inner');
                if (!inner) return;
                
                const delay = calculateStaggerDelay(index, tiles.length);
                
                setTimeout(() => {
                    // Clear inline styles and add animation class
                    inner.style.transform = '';
                    inner.style.opacity = '';
                    tile.classList.add('spiral-in');
                    
                    // Remove spiral-in class after animation completes
                    setTimeout(() => {
                        tile.classList.remove('spiral-in');
                    }, TIMINGS.spiralInDuration);
                }, delay);
            });
            
            isBuilding = false;
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================

        async function initBoard() {
            renderPlaceholders();
            await populateBoard();
        }

        initBoard();
    </script>
</body>
</html>
